# LineGrouper
Для сборки jar файла необходимо запустить `./gradlew jar`
После успешной сборки LineGrouper.jar будет находиться в папочке build/libs


Далее для запуска файла, как и сказано в условии можно 
использовать комманду: (тогда выходной файл будет иметь навзвание `ouput.txt`)


```java -jar LineGrouper.jar <name-of-input-file>```


Также можно использовать комманду с указанием имени выходного файла:


```java -jar LineGrouper.jar <name-of-input-file> <name-of-output-file>```

### Результаты тестового набора:
Количество групп с более чем одной строкой: `1910`
выполняется за ~8s
Вот так замерял время (c помощью Windows PowerShell):
```agsl
PS C:\JavaProjects\LineGrouper\build\libs> Measure-Command {java -jar LineGrouper.jar C:\JavaProjects\LineGrouper\lng.txt }


Days              : 0
Hours             : 0
Minutes           : 0
Seconds           : 7
Milliseconds      : 933
Ticks             : 79335187
TotalDays         : 9,18231331018519E-05
TotalHours        : 0,00220375519444444
TotalMinutes      : 0,132225311666667
TotalSeconds      : 7,9335187
TotalMilliseconds : 7933,5187
```

### Идея решения и ассимптотика
Идея решения базируется на системе непересекающихся множеств
(СНМ или DSU), это такая структура данных в которую 
можно добавить новое множество, объединить два множества
и найти корень множества причем все операции выполняются
за O(1) (на самом деле там обратная функция аккермана, но при
больших значениях это примерно O(1))

Мы реализуем класс `LineGrouper`, в который можно добавить строку

Далее строку в `LineGrouper` мы будем поддерживать мапу
из индекса столбца и его значения в множество в dsu
и если по данному индексу и значению найдем уже существующее
в dsu множество то объеденим только что созданное множество 
(при каждом добавлении строки добавляем и соответствующее множество в dsu
при этом изначально это будет номер нашей строки) 
с множеством которое возьмем из мапы

В конце нам нужно будет просто пройтись по всем индексам строк
и сгруппировать их вызвав метод `dsu.find()`

Также для вывода ответа найдем то количество групп в которых
хотя бы >= 2 элемента, а также отсортируем их по убыванию размера

Таким образом, решение работает за O(n * m), где n - количество строк
m - максимальная длина строки

## Тестирование
Обратите внимание, что все классы протестированы с помощью `JUnit5`
и тесты раполагаются в модуле `test`

## Документация
Также ко всему коду написана javadoc документация